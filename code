#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <iomanip>
using namespace std;

// 1. Stock class to hold all financial data and factors
class Stock {
public:
    string ticker;
    double price;
    double momentum;
    double volatility;
    double volumeZScore;
    double compositeScore;

    Stock(string t, double p, double mom, double vol, double volZ)
        : ticker(t), price(p), momentum(mom), volatility(vol), volumeZScore(volZ), compositeScore(0) {}

    void print() const {
        cout << left << setw(8) << ticker 
             << "Price: " << setw(8) << price
             << "Mom: " << setw(8) << momentum
             << "Vol: " << setw(8) << volatility
             << "VolZ: " << setw(8) << volumeZScore
             << "Score: " << setw(10) << compositeScore << endl;
    }
};

// 2. Merge Sort Implementation for descending order by compositeScore
void merge(vector<Stock*>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<Stock*> leftArr(n1);
    vector<Stock*> rightArr(n2);

    for (int i = 0; i < n1; i++)
        leftArr[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        rightArr[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (leftArr[i]->compositeScore >= rightArr[j]->compositeScore) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

void mergeSort(vector<Stock*>& arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

// 3. Factor normalization utility
void normalizeFactor(vector<double>& factors) {
    if (factors.empty()) return;

    double sum = accumulate(factors.begin(), factors.end(), 0.0);
    double mean = sum / factors.size();

    double sq_sum = 0.0;
    for (double value : factors) {
        sq_sum += (value - mean) * (value - mean);
    }
    double stdev = sqrt(sq_sum / factors.size());

    for (double& value : factors) {
        if (stdev > 1e-10) {
            value = (value - mean) / stdev;
        } else {
            value = 0.0;
        }
    }
}

// 4. Main execution
int main() {
    cout << "=== MULTI-FACTOR STOCK RANKING ENGINE ===" << endl;
    cout << "Building portfolio from Indian equity universe...\n" << endl;

    // Create stock universe with realistic Indian stock data
    vector<Stock> stockUniverse = {
        Stock("RELIANCE", 2850.75, 0.15, 0.018, 2.1),  // Strong momentum, low vol
        Stock("TCS", 3850.20, 0.08, 0.012, 1.4),       // Moderate momentum, very low vol
        Stock("HDFCBANK", 1650.50, -0.05, 0.022, -0.8), // Negative momentum, higher vol
        Stock("INFY", 1850.30, 0.12, 0.015, 0.9),      // Good momentum, low vol
        Stock("ICICIBANK", 1050.45, 0.06, 0.025, 0.3), // Moderate momentum, higher vol
        Stock("BAJFIN", 7200.80, 0.22, 0.028, 1.8),    // High momentum, high vol
        Stock("WIPRO", 650.15, -0.02, 0.020, -0.2),    // Slight negative momentum
        Stock("HINDUNILVR", 2550.60, 0.04, 0.014, 0.6) // Stable, low momentum
    };

    // Create pointer vector for efficient sorting
    vector<Stock*> stockPtrs;
    for (Stock& stock : stockUniverse) {
        stockPtrs.push_back(&stock);
    }

    // Extract raw factors for normalization
    vector<double> momentums, volatilities, volumeZScores;
    for (Stock* s : stockPtrs) {
        momentums.push_back(s->momentum);
        volatilities.push_back(s->volatility);
        volumeZScores.push_back(s->volumeZScore);
    }

    // Normalize factors cross-sectionally
    normalizeFactor(momentums);
    normalizeFactor(volatilities);
    normalizeFactor(volumeZScores);

    // Define quantitative strategy weights
    const double wMomentum = 0.50;    // Prioritize momentum
    const double wVolatility = 0.30;  // Favor lower volatility (inverse)
    const double wVolume = 0.20;      // Consider volume spikes

    // Calculate composite scores
    for (int i = 0; i < stockPtrs.size(); i++) {
        double volScore = -volatilities[i]; // Inverse: lower volatility is better
        stockPtrs[i]->compositeScore = (wMomentum * momentums[i]) 
                                     + (wVolatility * volScore)
                                     + (wVolume * volumeZScores[i]);
    }

    // Rank using custom merge sort
    cout << "Ranking stocks using custom merge sort..." << endl;
    mergeSort(stockPtrs, 0, stockPtrs.size() - 1);

    // Display results
    cout << "\n" << string(100, '=') << endl;
    cout << "FINAL RANKINGS (Highest to Lowest Composite Score)" << endl;
    cout << string(100, '=') << endl;
    cout << left << setw(6) << "Rank" << setw(10) << "Ticker" 
         << setw(12) << "Price" << setw(12) << "Score" 
         << setw(15) << "Momentum(Z)" << setw(15) << "Volatility(Z)" 
         << setw(15) << "Volume(Z)" << endl;
    cout << string(100, '-') << endl;

    for (int i = 0; i < stockPtrs.size(); i++) {
        cout << setw(6) << i+1 
             << setw(10) << stockPtrs[i]->ticker
             << setw(12) << stockPtrs[i]->price
             << setw(12) << fixed << setprecision(4) << stockPtrs[i]->compositeScore
             << setw(15) << momentums[i] 
             << setw(15) << -volatilities[i]  // Show inverse vol for clarity
             << setw(15) << volumeZScores[i] << endl;
    }

    // Generate investment recommendation
    cout << "\n" << string(100, '=') << endl;
    cout << "INVESTMENT RECOMMENDATION" << endl;
    cout << string(100, '=') << endl;
    cout << "STRONG BUY (Long): " << stockPtrs[0]->ticker 
         << " (Rank 1, Score: " << stockPtrs[0]->compositeScore << ")" << endl;
    cout << "BUY (Long): " << stockPtrs[1]->ticker 
         << " (Rank 2, Score: " << stockPtrs[1]->compositeScore << ")" << endl;
    cout << "STRONG SELL (Short): " << stockPtrs[stockPtrs.size()-1]->ticker 
         << " (Rank " << stockPtrs.size() << ", Score: " 
         << stockPtrs[stockPtrs.size()-1]->compositeScore << ")" << endl;

    // Strategy performance summary
    cout << "\n" << string(100, '=') << endl;
    cout << "STRATEGY SUMMARY" << endl;
    cout << string(100, '=') << endl;
    cout << "• Universe: " << stockPtrs.size() << " large-cap Indian stocks" << endl;
    cout << "• Factors: Momentum (" << wMomentum*100 << "%), " 
         << "Inverse Volatility (" << wVolatility*100 << "%), "
         << "Volume Spike (" << wVolume*100 << "%)" << endl;
    cout << "• Sorting: Custom merge sort (O(n log n) worst-case)" << endl;
    cout << "• Objective: Rank stocks by combined alpha signal strength" << endl;

    return 0;
}
